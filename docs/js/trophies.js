// trophies.js
import { tg, $, hapticTapSmart, hapticOK, hapticERR, hideKeyboard } from './telegram.js';
import { showScreen, focusAndScrollIntoView } from './ui.js';
import { shake, createFileKey, isImageFile } from './utils.js';
import { fetchProfile, submitTrophyApplication, fetchTrophies } from './api.js';

// –≠–ª–µ–º–µ–Ω—Ç—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
const obtainedTrophiesListEl = $('obtainedTrophiesList');
const availableTrophiesListEl = $('availableTrophiesList');
const noObtainedTrophiesHintEl = $('noObtainedTrophiesHint');
const noAvailableTrophiesHintEl = $('noAvailableTrophiesHint');
const trophyProgressFillEl = $('trophyProgressFill');
const trophyProgressTextEl = $('trophyProgressText');

const trophyTitleEl = $('trophyTitle');
const trophyDescEl = $('trophyDesc');
const trophyObtainedCardEl = $('trophyObtainedCard');
const trophyApplicationCardEl = $('trophyApplicationCard');

const proofFormEl = $('proofForm');
const proofFilesEl = $('proofFiles');
const proofSubmitBtn = $('proofSubmitBtn');
const commentEl = $('commentText');
const previewEl = $('filePreview');
const proofAddBtn = $('proofAddBtn');
const MAX_PROOF_FILES = 10;

const TROPHIES_URL = './assets/data/trophies.json';

let TROPHIES = null;
let USER_PROFILE = null;
let CURRENT_TROPHY_ID = null;

async function loadTrophies() {
  if (TROPHIES) return TROPHIES;
  try {
    // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç—Ä–æ—Ñ–µ–∏ –∏–∑ API –≤–º–µ—Å—Ç–æ JSON —Ñ–∞–π–ª–∞
    TROPHIES = await fetchTrophies();
    console.log('–ó–∞–≥—Ä—É–∂–µ–Ω—ã —Ç—Ä–æ—Ñ–µ–∏ –∏–∑ API:', TROPHIES);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç—Ä–æ—Ñ–µ–µ–≤:', error);
    TROPHIES = [];
  }
  return TROPHIES;
}

async function loadUserProfile() {
  try {
    USER_PROFILE = await fetchProfile();
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ—Ñ–∏–ª—è:', error);
    USER_PROFILE = null;
  }
  return USER_PROFILE;
}

function renderProgressBar() {
  if (!trophyProgressFillEl || !trophyProgressTextEl) return;
  
  const totalTrophies = (TROPHIES || []).length;
  const obtainedTrophies = USER_PROFILE?.trophies?.length || 0;
  
  const percentage = totalTrophies > 0 ? (obtainedTrophies / totalTrophies) * 100 : 0;
  
  trophyProgressFillEl.style.width = `${percentage}%`;
  trophyProgressTextEl.textContent = `${obtainedTrophies}/${totalTrophies}`;
}

function renderObtainedTrophies() {
  if (!obtainedTrophiesListEl) return;
  
  obtainedTrophiesListEl.innerHTML = '';
  
  // –ü–æ–ª—É—á–∞–µ–º —Ç—Ä–æ—Ñ–µ–∏ –∏–∑ –º–∞—Å—Å–∏–≤–∞ (—Ç–µ–ø–µ—Ä—å API –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞—Å—Å–∏–≤)
  const obtainedTrophyNames = USER_PROFILE?.trophies || [];
  
  if (obtainedTrophyNames.length === 0) {
    noObtainedTrophiesHintEl?.classList.remove('hidden');
    return;
  }
  
  noObtainedTrophiesHintEl?.classList.add('hidden');
  
  obtainedTrophyNames.forEach(trophyName => {
    // –ù–∞—Ö–æ–¥–∏–º —Ç—Ä–æ—Ñ–µ–π –≤ —Å–ø–∏—Å–∫–µ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
    const trophy = TROPHIES?.find(t => t.trophy_name === trophyName);
    if (!trophy) return;
    
    const btn = document.createElement('button');
    btn.className = 'list-btn trophy-obtained';
    btn.type = 'button';
    btn.dataset.id = trophy.trophy_id;
    btn.innerHTML = `<span>${trophy.trophy_name}</span><span class="right">‚úì</span>`;
    btn.addEventListener('click', () => { 
      hapticTapSmart(); 
      openTrophyDetail(trophy.trophy_id, true); 
    });
    obtainedTrophiesListEl.appendChild(btn);
  });
}

function renderAvailableTrophies() {
  if (!availableTrophiesListEl) return;
  
  availableTrophiesListEl.innerHTML = '';
  
  // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ —Ç—Ä–æ—Ñ–µ–∏ –∏–∑ –º–∞—Å—Å–∏–≤–∞ (—Ç–µ–ø–µ—Ä—å API –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞—Å—Å–∏–≤)
  const obtainedTrophyNames = USER_PROFILE?.trophies || [];
  
  // –§–∏–ª—å—Ç—Ä—É–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ç—Ä–æ—Ñ–µ–∏ (—Ç–µ, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
  const availableTrophies = (TROPHIES || []).filter(trophy => !obtainedTrophyNames.includes(trophy.trophy_name));
  
  if (availableTrophies.length === 0) {
    noAvailableTrophiesHintEl?.classList.remove('hidden');
    return;
  }
  
  noAvailableTrophiesHintEl?.classList.add('hidden');
  
  availableTrophies.forEach(trophy => {
    const btn = document.createElement('button');
    btn.className = 'list-btn';
    btn.type = 'button';
    btn.dataset.id = trophy.trophy_id;
    btn.innerHTML = `<span>${trophy.trophy_name}</span><span class="right">‚Ä∫</span>`;
    btn.addEventListener('click', () => { 
      hapticTapSmart(); 
      openTrophyDetail(trophy.trophy_id, false); 
    });
    availableTrophiesListEl.appendChild(btn);
  });
}

function resetProofForm() {
  // –û—á–∏—â–∞–µ–º objectURL –ø—Ä–∏ —Å–±—Ä–æ—Å–µ —Ñ–æ—Ä–º—ã
  objectURLs.forEach(url => URL.revokeObjectURL(url));
  objectURLs.clear();
  
  if (previewEl) { previewEl.innerHTML = ''; previewEl.classList.remove('shake','error'); }
  if (proofFilesEl) proofFilesEl.value = '';
  proofSelected = [];
  if (commentEl) {
    commentEl.value = '';
    commentEl.style.height = 'auto';
    commentEl.classList.remove('shake','error');
  }
}

let proofSelected = [];
let objectURLs = new Set();

function renderProofPreview() {
  if (!previewEl) return;
  
  // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ objectURL
  objectURLs.forEach(url => URL.revokeObjectURL(url));
  objectURLs.clear();
  
  previewEl.innerHTML = '';
  const limit = 4;
  const toShow = proofSelected.slice(0, limit);

  toShow.forEach((file, idx) => {
    const tile = document.createElement('div');
    tile.className = 'preview-item removable';
    tile.title = '–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å';

    if (isImageFile(file)) {
      const img = document.createElement('img');
      const objectURL = URL.createObjectURL(file);
      objectURLs.add(objectURL);
      img.src = objectURL;
      img.onload = () => {
        // URL –±—É–¥–µ—Ç –æ—Ç–æ–∑–≤–∞–Ω –ø—Ä–∏ —Å–ª–µ–¥—É—é—â–µ–º –≤—ã–∑–æ–≤–µ renderProofPreview
      };
      tile.appendChild(img);
    } else {
      tile.textContent = 'üìÑ';
    }

    tile.addEventListener('click', () => {
      proofSelected.splice(idx, 1);
      hapticTapSmart();
      renderProofPreview();
    });

    previewEl.appendChild(tile);
  });

  if (proofSelected.length > limit) {
    const more = document.createElement('div');
    more.className = 'preview-more';
    more.textContent = `+${proofSelected.length - limit}`;
    previewEl.appendChild(more);
  }
}

function openTrophyDetail(trophyId, isObtained = false) {
  // –ù–∞—Ö–æ–¥–∏–º —Ç—Ä–æ—Ñ–µ–π –≤ –º–∞—Å—Å–∏–≤–µ –ø–æ trophy_id
  const trophy = (TROPHIES || []).find(t => t.trophy_id == trophyId) || {};
  CURRENT_TROPHY_ID = trophyId;
  
  if (trophyTitleEl) trophyTitleEl.textContent = trophy.trophy_name || '–¢—Ä–æ—Ñ–µ–π';
  if (trophyDescEl) {
    trophyDescEl.innerHTML = '';
    const description = trophy.description || '–û–ø–∏—Å–∞–Ω–∏–µ —Å–∫–æ—Ä–æ –±—É–¥–µ—Ç.';
    // –†–∞–∑–±–∏–≤–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –ø–æ –ø–µ—Ä–µ–Ω–æ—Å–∞–º —Å—Ç—Ä–æ–∫
    const lines = description.split('\n').filter(line => line.trim());
    lines.forEach((line) => {
      const li = document.createElement('li');
      li.textContent = line;
      trophyDescEl.appendChild(li);
    });
  }
  
  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–∞—Ä—Ç–æ—á–∫—É
  if (isObtained) {
    trophyObtainedCardEl?.classList.remove('hidden');
    trophyApplicationCardEl?.classList.add('hidden');
    proofSubmitBtn?.classList.add('hidden');
  } else {
    trophyObtainedCardEl?.classList.add('hidden');
    trophyApplicationCardEl?.classList.remove('hidden');
    proofSubmitBtn?.classList.remove('hidden');
  }
  
  resetProofForm();
  showScreen('trophyDetail');
}

let submitting = false;
async function submitProof() {
  if (submitting) return;
  submitting = true;
  
  const submitBtn = document.getElementById('proofSubmitBtn');
  const originalText = submitBtn?.textContent || '–û—Ç–ø—Ä–∞–≤–∏—Ç—å';
  
  // –ë–ª–æ–∫–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É –∏ –º–µ–Ω—è–µ–º —Ç–µ–∫—Å—Ç
  if (submitBtn) {
    submitBtn.disabled = true;
    submitBtn.classList.add('success');
    submitBtn.textContent = '–ü–æ–¥–æ–∂–¥–∏—Ç–µ...';
  }

  const filesCount = proofSelected.length;
  const comment = (commentEl?.value || '').trim();

  if (filesCount === 0) {
    shake(previewEl || proofAddBtn || proofFilesEl); 
    focusAndScrollIntoView(proofAddBtn || previewEl);
    hapticERR();
    tg?.showPopup?.({ title: '–û—à–∏–±–∫–∞', message: '–î–æ–±–∞–≤—å—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.', buttons: [{ type: 'ok' }] });
    
    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–Ω–æ–ø–∫—É
    if (submitBtn) {
      submitBtn.disabled = false;
      submitBtn.classList.remove('success');
      submitBtn.textContent = originalText;
    }
    submitting = false;
    return;
  }

  try {
    hapticOK();
    
    await submitTrophyApplication(CURRENT_TROPHY_ID, proofSelected, comment);
    
    tg?.showPopup?.({ 
      title: '–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞', 
      message: '‚úÖ –ú–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã —Ä–∞—Å—Å–º–æ—Ç—Ä—è—Ç –≤–∞—à—É –∑–∞—è–≤–∫—É.', 
      buttons: [{ type: 'ok' }] 
    });
    
    resetProofForm();
    showScreen('trophies');
    
    // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    await loadUserProfile();
    renderAll();
    
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞—è–≤–∫–∏:', error);
    hapticERR();
    tg?.showPopup?.({ 
      title: '–û—à–∏–±–∫–∞', 
      message: error.message || '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞—è–≤–∫–∏.', 
      buttons: [{ type: 'ok' }] 
    });
  } finally {
    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–Ω–æ–ø–∫—É
    if (submitBtn) {
      submitBtn.disabled = false;
      submitBtn.classList.remove('success');
      submitBtn.textContent = originalText;
    }
    submitting = false;
  }
}

function renderAll() {
  renderProgressBar();
  renderObtainedTrophies();
  renderAvailableTrophies();
}

export async function initTrophies() {
  // –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
  await Promise.all([
    loadTrophies(),
    loadUserProfile()
  ]);
  
  // –†–µ–Ω–¥–µ—Ä–∏–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
  renderAll();

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è —Ñ–æ—Ä–º—ã –∑–∞—è–≤–∫–∏
  proofAddBtn?.addEventListener('click', () => {
    hapticTapSmart();
    try { proofFilesEl.value = ''; } catch {}
    proofFilesEl?.click();
  });

  if (proofFilesEl) {
    proofFilesEl.addEventListener('change', () => {
      const files = Array.from(proofFilesEl.files || []);
      if (!files.length) { 
        shake(previewEl || proofAddBtn); 
        focusAndScrollIntoView(proofAddBtn || previewEl); 
        return; 
      }

      // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      const imageFiles = files.filter(file => isImageFile(file));
      
      if (imageFiles.length !== files.length) {
        tg?.showPopup?.({
          title: '–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç',
          message: '–†–∞–∑—Ä–µ—à–µ–Ω—ã —Ç–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.',
          buttons: [{ type: 'ok' }]
        });
      }

      const keyOf = (f) => createFileKey(f);
      const existing = new Set(proofSelected.map(keyOf));
      const freeSlots = Math.max(0, MAX_PROOF_FILES - proofSelected.length);
      const incoming = imageFiles.filter(f => !existing.has(keyOf));

      if (incoming.length > freeSlots) {
        incoming.length = freeSlots;
        tg?.showPopup?.({
          title: '–õ–∏–º–∏—Ç —Ñ–∞–π–ª–æ–≤',
          message: `–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –Ω–µ –±–æ–ª–µ–µ ${MAX_PROOF_FILES} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.`,
          buttons: [{ type: 'ok' }]
        });
      }
      incoming.forEach(f => proofSelected.push(f));
      renderProofPreview();
    });
  }

  if (commentEl) {
    const autoResize = () => {
      commentEl.style.height = 'auto';
      commentEl.style.height = Math.min(commentEl.scrollHeight, 200) + 'px';
    };
    commentEl.addEventListener('input', autoResize);
    commentEl.addEventListener('focus', ()=>{ hapticTapSmart(); }, {passive:true});
    setTimeout(autoResize, 0);
  }

  proofSubmitBtn?.addEventListener('pointerdown', () => { hapticTapSmart(); });
  proofSubmitBtn?.addEventListener('click', (e) => { e.preventDefault?.(); submitProof(); });

  proofFormEl?.addEventListener('submit', (e) => { e.preventDefault(); submitProof(); });
}